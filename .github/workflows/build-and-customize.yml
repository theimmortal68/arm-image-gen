name: Build and Customize (Klipper Suite)

on:
  workflow_dispatch:
    inputs:
      devices:
        description: "Comma-separated device list (e.g. rpi64,orangepi5max)"
        required: false
        default: "rpi64"

permissions:
  actions: read
  contents: read

concurrency:
  group: build-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Turn CSV input into a JSON array for matrix
  prepare-matrix:
    runs-on: ubuntu-latest
    outputs:
      devices: ${{ steps.mk.outputs.devices }}
    steps:
      - id: mk
        shell: bash
        run: |
          set -euo pipefail
          CSV="${{ github.event.inputs.devices }}"
          # Split on comma, trim whitespace, drop empties, emit JSON array
          json="[$(
            printf '%s' "$CSV" \
            | tr ',' '\n' \
            | awk '{$1=$1}1' \
            | awk 'length>0{printf "\"%s\",",$0}' \
            | sed 's/,$//'
          )]"
          echo "devices=$json" >> "$GITHUB_OUTPUT"
          echo "Using matrix: $json"

  # =========================
  # 1) Build the base image
  # =========================
  build:
    runs-on: ubuntu-latest
    needs: prepare-matrix
    strategy:
      fail-fast: false
      matrix:
        device: ${{ fromJSON(needs.prepare-matrix.outputs.devices) }}
    env:
      DEVICE: ${{ matrix.device }}
      # Optional pins; adjust if you want different versions
      MM_TAG: "1.5.7"
      BDEB_REF: "v0.7.0"
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Apt prep
        run: |
          set -eux
          sudo apt-get update
          sudo apt-get install -y \
            qemu-user-static binfmt-support qemu-utils kpartx dosfstools \
            parted e2fsprogs rsync xz-utils ca-certificates curl git \
            arch-test pandoc jq unzip util-linux udev mount kmod file \
            perl python3-pip debian-archive-keyring gnupg

      - name: Enable binfmts (arm/arm64)
        run: |
          set -eux
          sudo update-binfmts --enable qemu-aarch64 || true
          sudo update-binfmts --enable qemu-arm || true
          arch-test arm64
          qemu-aarch64-static --version

      - name: Install mmdebstrap (pinned)
        run: |
          set -eux
          rm -rf mmdebstrap-src
          git clone --depth=1 --branch "${MM_TAG}" \
            https://gitlab.mister-muffin.de/josch/mmdebstrap.git mmdebstrap-src || {
            echo "Tag ${MM_TAG} missing without 'v' prefix, retryingâ€¦"
            git clone --depth=1 --branch "v${MM_TAG}" \
              https://gitlab.mister-muffin.de/josch/mmdebstrap.git mmdebstrap-src
          }
          sudo install -D -m 0755 mmdebstrap-src/mmdebstrap /usr/local/bin/mmdebstrap

      - name: Install bdebstrap (runner local user)
        run: |
          set -eux
          python3 -m pip install --user --upgrade pip wheel
          python3 -m pip install --user "git+https://github.com/bdrung/bdebstrap@${BDEB_REF}"
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Build rootfs with bdebstrap
        run: |
          set -eux
          bash scripts/build-bdebstrap.sh "${DEVICE}" "devices/${DEVICE}/layers.yaml" "out/${DEVICE}-bookworm-arm64"

      - name: Make bootable image (Raspberry Pi)
        if: startsWith(matrix.device, 'rpi')
        run: |
          set -eux
          sudo bash scripts/make-img-rpi.sh "out/${DEVICE}-bookworm-arm64/rootfs" "build/input-${DEVICE}.img"
          ls -lh build

      - name: Make bootable image (Armbian devices)
        if: startsWith(matrix.device, 'orange')
        run: |
          set -eux
          # Implement this script for your Armbian targets when ready:
          # it should create build/input-${DEVICE}.img from the rootfs.
          sudo bash scripts/make-img-armbian.sh "out/${DEVICE}-bookworm-arm64/rootfs" "build/input-${DEVICE}.img"

      - name: Package base artifact (ZIP)
        run: |
          set -eux
          mkdir -p artifacts
          zip -r "artifacts/base-input-${DEVICE}.zip" "build/input-${DEVICE}.img"

      - name: Upload base artifact
        uses: actions/upload-artifact@v4
        with:
          name: base-input-${{ env.DEVICE }}
          path: artifacts/base-input-${{ env.DEVICE }}.zip
          if-no-files-found: error
          retention-days: 7

  # =========================
  # 2) Customize via CustoPiZer
  # =========================
  customize:
    runs-on: ubuntu-latest
    needs: [prepare-matrix, build]
    strategy:
      fail-fast: false
      matrix:
        device: ${{ fromJSON(needs.prepare-matrix.outputs.devices) }}
    env:
      DEVICE: ${{ matrix.device }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Ensure custom.d present & executable
        shell: bash
        run: |
          set -eux
          test -d custopizer/custom.d
          chmod -R a+rx custopizer/custom.d

      - name: Download base artifact from build job (no unzip)
        uses: actions/download-artifact@v4
        with:
          name: base-input-${{ env.DEVICE }}
          path: build
          merge-multiple: false

      - name: Extract artifact safely (handles >2GiB)
        shell: bash
        run: |
          set -eux
          ls -l build || true
          ZIP="$(find build -maxdepth 1 -type f -name '*.zip' | head -n1 || true)"
          if [ -z "${ZIP}" ]; then
            echo "No ZIP artifact found in build/"; exit 1
          fi

          sudo apt-get update
          if sudo apt-get install -y unzip; then
            unzip -o "${ZIP}" -d build || { sudo apt-get install -y p7zip-full; 7z x -y -o"build" "${ZIP}"; }
          else
            sudo apt-get install -y p7zip-full
            7z x -y -o"build" "${ZIP}"
          fi
          ls -l build

      - name: Normalize image path (supports .img and .img.xz)
        shell: bash
        run: |
          set -eux
          SRC="$(find build -maxdepth 4 -type f \( -name "input-${DEVICE}.img" -o -name "input-${DEVICE}.img.xz" -o -name "input-*.img" -o -name "input-*.img.xz" \) | head -n1 || true)"
          [ -n "${SRC}" ] || { echo "No input image found after extraction"; exit 1; }

          if [[ "${SRC}" == *.xz ]]; then
            sudo apt-get update && sudo apt-get install -y xz-utils
            xz -T0 -dk "${SRC}"   # keep .xz, emit .img alongside
            SRC="${SRC%.xz}"
          fi

          mkdir -p build
          mv -f "${SRC}" "build/input-${DEVICE}.img" || true
          mv -f "build/input-${DEVICE}.img" "build/input.img"
          ls -lh build
          
      - name: Pre-fix sudo perms inside input.img (non-interactive)
        shell: bash
        run: |
          set -euxo pipefail
          # Fix sudo/su ownership & setuid *inside* the image before CustoPiZer runs
          docker run --rm --privileged \
            -v "${GITHUB_WORKSPACE}/build/input.img:/image.img" \
            --entrypoint /bin/sh \
            ghcr.io/octoprint/custopizer:latest \
            -ec '
              set -eu
              apt-get update
              apt-get install -y kpartx e2fsprogs util-linux

              LOOP=$(losetup -Pf --show /image.img)
              partprobe "$LOOP" || true
              kpartx -av "$LOOP"

              MAP=$(basename "$LOOP")
              ROOTP=""
              if [ -e "/dev/mapper/${MAP}p2" ]; then
                ROOTP="/dev/mapper/${MAP}p2"
              else
                for p in /dev/mapper/${MAP}p*; do
                  [ -e "$p" ] || continue
                  if lsblk -no FSTYPE "$p" 2>/dev/null | grep -q "^ext4$"; then ROOTP="$p"; break; fi
                done
              fi
              [ -n "$ROOTP" ]

              mkdir -p /mnt/rootfs
              mount "$ROOTP" /mnt/rootfs

              chown 0:0 /mnt/rootfs/usr/bin/sudo  || true
              chmod 4755 /mnt/rootfs/usr/bin/sudo || true
              chown 0:0 /mnt/rootfs/etc/sudo.conf /mnt/rootfs/etc/sudoers || true
              chmod 0440 /mnt/rootfs/etc/sudoers  || true
              for su in /mnt/rootfs/bin/su /mnt/rootfs/usr/bin/su; do
                [ -e "$su" ] && { chown 0:0 "$su" || true; chmod 4755 "$su" || true; }
              done

              umount /mnt/rootfs
              kpartx -dv "$LOOP"
              losetup -d "$LOOP"

      - name: Generate CustoPiZer config.local
        shell: bash
        run: |
          set -eux
          case "${DEVICE}" in
            rpi*|raspberrypi*) DISTRO="raspbian" ;;
            *)                 DISTRO="armbian"  ;;
          esac
          cat > "${GITHUB_WORKSPACE}/config.local" <<EOF
          EDITBASE_DISTRO=${DISTRO}
          EDITBASE_MOUNT_PROC=1
          EDITBASE_MOUNT_SYS=1
          EDITBASE_IMAGE_ENLARGEROOT=8000
          EDITBASE_IMAGE_RESIZEROOT=100
          EDITBASE_ARCH=arm64
          EOF
          cat "${GITHUB_WORKSPACE}/config.local"

      - name: Pull CustoPiZer image
        run: |
          set -eux
          docker pull ghcr.io/octoprint/custopizer:latest

      - name: Run CustoPiZer (bind custom.d, explicit DNS)
        shell: bash
        run: |
          set -eux
          docker run --rm --privileged \
            --dns 8.8.8.8 --dns 1.1.1.1 \
            -v "${GITHUB_WORKSPACE}/build:/CustoPiZer/workspace" \
            -v "${GITHUB_WORKSPACE}/custopizer/custom.d:/CustoPiZer/workspace/scripts" \
            -v "${GITHUB_WORKSPACE}/config.local:/CustoPiZer/config.local" \
            ghcr.io/octoprint/custopizer:latest

          mv -f "${GITHUB_WORKSPACE}/build/output.img" \
                "${GITHUB_WORKSPACE}/build/output-${DEVICE}.img"
          ls -lh build

      - name: Take ownership of output (post-CustoPiZer)
        shell: bash
        run: |
          set -eux
          sudo chown -R "$USER":"$USER" build
          chmod -R u+rwX build

      - name: Compress output (.xz)
        shell: bash
        run: |
          set -eux
          sudo apt-get update && sudo apt-get install -y xz-utils
          xz -T0 -9e -f "build/output-${DEVICE}.img"
          ls -lh build

      - name: Upload customized image (.img.xz)
        uses: actions/upload-artifact@v4
        with:
          name: output-${{ env.DEVICE }}.img.xz
          path: build/output-${{ env.DEVICE }}.img.xz
          if-no-files-found: error
          retention-days: 7
