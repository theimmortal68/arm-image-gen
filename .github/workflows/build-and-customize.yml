name: Build and Customize

on:
  push:                    # run after every commit/push
    branches:
      - '**'
  workflow_dispatch:
    inputs:
      device:
        description: "Single device (e.g. rpi64, opi5). Leave blank to use default."
        required: false
        default: ""
      devices:
        description: "CSV list of devices (e.g. rpi64,opi5). Overrides 'device' if set."
        required: false
        default: ""

permissions:
  contents: read

# Global default when nothing is provided
env:
  DEVICE: rpi64

concurrency:
  group: build-and-customize-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Turn CSV input into a JSON array for matrix
  prepare-matrix:
    runs-on: ubuntu-latest
    outputs:
      devices: ${{ steps.mk.outputs.devices }}
    steps:
      - id: mk
        name: Make device matrix
        shell: bash
        env:
          # Priority: CSV input > single device input > env.DEVICE > 'rpi64'
          CSV: ${{ github.event.inputs.devices || github.event.inputs.device || env.DEVICE || 'rpi64' }}
        run: |
          set -euo pipefail
          CSV="${CSV:-rpi64}"
          # Split on comma, trim whitespace, drop empties, emit JSON array
          json="[$(
            printf '%s' "$CSV" \
            | tr ',' '\n' \
            | awk '{$1=$1}1' \
            | awk 'length>0{printf "\"%s\",",$0}' \
            | sed 's/,$//'
          )]"
          [ "$json" = "[]" ] && json='["rpi64"]'
          echo "devices=$json" >> "$GITHUB_OUTPUT"
          echo "Using matrix: $json"

  # =========================
  # 1) Build the base image
  # =========================
  build:
    runs-on: ubuntu-latest
    needs: prepare-matrix
    strategy:
      fail-fast: false
      matrix:
        device: ${{ fromJson(needs.prepare-matrix.outputs.devices || '["rpi64"]') }}
    env:
      DEVICE: ${{ matrix.device }}
      # Optional pins; adjust if you want different versions
      MM_TAG: "1.5.7"
      BDEB_REF: "v0.7.0"
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      # Optional: free disk space if your image build is large (uncomment if needed)
      # - name: Free some disk space
      #   run: |
      #     sudo rm -rf /usr/local/lib/android || true
      #     sudo rm -rf /opt/ghc || true
      #     sudo rm -rf /usr/share/dotnet || true
      #     df -h

      - name: Apt prep (update & base tools)
        run: |
          set -eux pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            qemu-user-static binfmt-support qemu-utils kpartx dosfstools \
            parted e2fsprogs rsync xz-utils ca-certificates curl git \
            arch-test pandoc jq unzip util-linux udev mount kmod file \
            perl python3-pip debian-archive-keyring gnupg  pigz \
            p7zip-full parted bmap-tools debootstrap

#      - name: Enable binfmts (arm/arm64)
#        run: |
#          set -eux pipefail
#          sudo update-binfmts --enable qemu-aarch64 || true
#          sudo update-binfmts --enable qemu-arm || true
#          arch-test arm64
#          qemu-aarch64-static --version

      - name: Install mmdebstrap (pinned)
        run: |
          set -eux pipefail
          rm -rf mmdebstrap-src
          git clone --depth=1 --branch "${MM_TAG}" \
            https://gitlab.mister-muffin.de/josch/mmdebstrap.git mmdebstrap-src || {
            echo "Tag ${MM_TAG} missing without 'v' prefix, retryingâ€¦"
            git clone --depth=1 --branch "v${MM_TAG}" \
              https://gitlab.mister-muffin.de/josch/mmdebstrap.git mmdebstrap-src
          }
          sudo install -D -m 0755 mmdebstrap-src/mmdebstrap /usr/local/bin/mmdebstrap

      - name: Install bdebstrap (runner local user)
        run: |
          set -eux pipefail
          python3 -m pip install --user --upgrade pip wheel
          python3 -m pip install --user "git+https://github.com/bdrung/bdebstrap@${BDEB_REF}"
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

     # (Optional) QEMU/Buildx if you containerize parts of the build
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm,arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Show selected device
        run: echo "DEVICE=${DEVICE}"

      - name: Build rootfs with bdebstrap
        env:
          DEVICE: ${{ env.DEVICE }}
        run: |
          set -eux pipefail
          bash scripts/build-bdebstrap.sh "${DEVICE}" "devices/${DEVICE}/layers.yaml" "out/${DEVICE}-bookworm-arm64"

      - name: Make bootable image (Raspberry Pi)
        if: startsWith(matrix.device, 'rpi')
        run: |
          set -eux pipefail
          sudo bash scripts/make-img-rpi.sh "out/${DEVICE}-bookworm-arm64/rootfs" "build/input-${DEVICE}.img"
          ls -lh build

      - name: Make bootable image (Armbian devices)
        if: startsWith(matrix.device, 'orange')
        run: |
          set -eux pipefail
          # Implement this script for your Armbian targets when ready:
          # it should create build/input-${DEVICE}.img from the rootfs.
          sudo bash scripts/make-img-armbian.sh "out/${DEVICE}-bookworm-arm64/rootfs" "build/input-${DEVICE}.img"

      - name: Package base artifact (ZIP)
        run: |
          set -eux pipefail
          mkdir -p artifacts
          zip -r "artifacts/base-input-${DEVICE}.zip" "build/input-${DEVICE}.img"

      - name: Upload base artifact
        uses: actions/upload-artifact@v4
        with:
          name: base-input-${{ env.DEVICE }}
          path: artifacts/base-input-${{ env.DEVICE }}.zip
          if-no-files-found: error
          retention-days: 7

  # =========================
  # 2) Customize via CustoPiZer
  # =========================
  customize:
    runs-on: ubuntu-latest
    needs: [prepare-matrix, build]
    strategy:
      fail-fast: false
      matrix:
        device: ${{ fromJSON(needs.prepare-matrix.outputs.devices) }}
    env:
      DEVICE: ${{ matrix.device }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Ensure custom.d present & executable
        shell: bash
        run: |
          set -eux pipefail
          test -d custopizer/custom.d
          chmod -R a+rx custopizer/custom.d

      - name: Download base artifact from build job (no unzip)
        uses: actions/download-artifact@v4
        with:
          name: base-input-${{ env.DEVICE }}
          path: build
          merge-multiple: false

      - name: Extract artifact safely (handles >2GiB)
        shell: bash
        run: |
          set -eux pipefail
          ls -l build || true
          ZIP="$(find build -maxdepth 1 -type f -name '*.zip' | head -n1 || true)"
          if [ -z "${ZIP}" ]; then
            echo "No ZIP artifact found in build/"; exit 1
          fi

          sudo apt-get update
          if sudo apt-get install -y unzip; then
            unzip -o "${ZIP}" -d build || { sudo apt-get install -y p7zip-full; 7z x -y -o"build" "${ZIP}"; }
          else
            sudo apt-get install -y p7zip-full
            7z x -y -o"build" "${ZIP}"
          fi
          ls -l build

      - name: Normalize image path (supports .img and .img.xz)
        shell: bash
        run: |
          set -eux pipefail
          SRC="$(find build -maxdepth 4 -type f \( -name "input-${DEVICE}.img" -o -name "input-${DEVICE}.img.xz" -o -name "input-*.img" -o -name "input-*.img.xz" \) | head -n1 || true)"
          [ -n "${SRC}" ] || { echo "No input image found after extraction"; exit 1; }

          if [[ "${SRC}" == *.xz ]]; then
            sudo apt-get update && sudo apt-get install -y xz-utils
            xz -T0 -dk "${SRC}"   # keep .xz, emit .img alongside
            SRC="${SRC%.xz}"
          fi

          mkdir -p build
          mv -f "${SRC}" "build/input-${DEVICE}.img" || true
          mv -f "build/input-${DEVICE}.img" "build/input.img"
          ls -lh build
          
      - name: Pre-fix sudo perms inside input.img (non-interactive)
        shell: bash
        run: |
          set -euxo pipefail

          # Sanity: the normalized path must exist
          test -f "${GITHUB_WORKSPACE}/build/input.img"

          # Use a privileged Custopizer container to manipulate the image safely
          # (privileged is required for loop + device-mapper via kpartx)
          docker run --rm --privileged \
            -v "${GITHUB_WORKSPACE}/build/input.img:/image.img" \
            --entrypoint /usr/bin/env \
            ghcr.io/octoprint/custopizer:latest \
            bash -euxo pipefail -c '
              set -euo pipefail

              apt-get update
              DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
                kpartx e2fsprogs util-linux mount udev

              cleanup() {
                set +e
                sync
                umount /mnt/rootfs 2>/dev/null || true
                if [ -n "${MAP:-}" ]; then kpartx -dv "$LOOP" 2>/dev/null || true; fi
                losetup -d "$LOOP" 2>/dev/null || true
              }
              trap cleanup EXIT

              LOOP=$(losetup -Pf --show /image.img)
              partprobe "$LOOP" || true
              kpartx -av "$LOOP"
              MAP=$(basename "$LOOP")
              # Wait a moment for /dev/mapper nodes to appear
              udevadm settle || true

              # Prefer p2; otherwise pick the first ext4 partition
              ROOTP=""
              if [ -e "/dev/mapper/${MAP}p2" ]; then
                ROOTP="/dev/mapper/${MAP}p2"
              else
                for p in /dev/mapper/${MAP}p*; do
                  [ -e "$p" ] || continue
                  if lsblk -no FSTYPE "$p" 2>/dev/null | grep -q "^ext4$"; then ROOTP="$p"; break; fi
                done
              fi
              [ -n "$ROOTP" ]

              mkdir -p /mnt/rootfs
              mount "$ROOTP" /mnt/rootfs

              # Fix sudo/su ownership + setuid inside the image
              if [ -e /mnt/rootfs/usr/bin/sudo ]; then
                chown 0:0 /mnt/rootfs/usr/bin/sudo  || true
                chmod 4755 /mnt/rootfs/usr/bin/sudo || true
              fi
              # sudoers must be root:root and 0440
              if [ -e /mnt/rootfs/etc/sudoers ]; then
                chown 0:0 /mnt/rootfs/etc/sudoers || true
                chmod 0440 /mnt/rootfs/etc/sudoers || true
              fi
              # Optional: sudo.conf if present
              [ -e /mnt/rootfs/etc/sudo.conf ] && chown 0:0 /mnt/rootfs/etc/sudo.conf || true

              # su can be in /bin or /usr/bin depending on base
              for su in /mnt/rootfs/bin/su /mnt/rootfs/usr/bin/su; do
                [ -e "$su" ] && { chown 0:0 "$su" || true; chmod 4755 "$su" || true; }
              done
            '

      - name: Generate CustoPiZer config.local
        shell: bash
        run: |
          set -eux pipefail
          case "${DEVICE}" in
            rpi*|raspberrypi*) DISTRO="raspbian" ;;
            *)                 DISTRO="armbian"  ;;
          esac
          cat > "${GITHUB_WORKSPACE}/config.local" <<EOF
          EDITBASE_DISTRO=${DISTRO}
          EDITBASE_MOUNT_PROC=1
          EDITBASE_MOUNT_SYS=1
          EDITBASE_IMAGE_ENLARGEROOT=8000
          EDITBASE_IMAGE_RESIZEROOT=100
          EDITBASE_ARCH=arm64
          EOF
          cat "${GITHUB_WORKSPACE}/config.local"

      - name: Pull CustoPiZer image
        run: |
          set -eux pipefail
          docker pull ghcr.io/octoprint/custopizer:latest

      - name: Run CustoPiZer (bind custom.d, explicit DNS)
        shell: bash
        run: |
          set -eux pipefail
          docker run --rm --privileged \
            --dns 8.8.8.8 --dns 1.1.1.1 \
            -v "${GITHUB_WORKSPACE}/build:/CustoPiZer/workspace" \
            -v "${GITHUB_WORKSPACE}/custopizer/custom.d:/CustoPiZer/workspace/scripts" \
            -v "${GITHUB_WORKSPACE}/config.local:/CustoPiZer/config.local" \
            ghcr.io/octoprint/custopizer:latest

          mv -f "${GITHUB_WORKSPACE}/build/output.img" \
                "${GITHUB_WORKSPACE}/build/output-${DEVICE}.img"
          ls -lh build

      - name: Take ownership of output (post-CustoPiZer)
        shell: bash
        run: |
          set -eux pipefail
          sudo chown -R "$USER":"$USER" build
          chmod -R u+rwX build

      - name: Compress output
        shell: bash
        run: |
          set -euxo pipefail
          xz -T0 -9e -c "build/output-${{ matrix.device }}.img" > "build/output-${{ matrix.device }}.img.xz"
          rm -f "build/output-${{ matrix.device }}.img"

      - name: Upload customized image (.img.xz)
        uses: actions/upload-artifact@v4
        with:
          name: output-${{ env.DEVICE }}.img.xz
          path: build/output-${{ env.DEVICE }}.img.xz
          if-no-files-found: error
          retention-days: 7
