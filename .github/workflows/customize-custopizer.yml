name: Customize with CustoPiZer

on:
  # Auto-trigger when the base workflow completes successfully
  workflow_run:
    workflows: [ "Build Base Image" ]
    types: [ completed ]
  # Manual trigger for focused debugging
  workflow_dispatch:
    inputs:
      device:
        description: "Target device (e.g. rpi64, orangepi5max)"
        required: true
        default: "rpi64"
      base_run_id:
        description: "Optional: specific run ID of 'Build Base Image' to pull from"
        required: false

permissions:
  actions: read
  contents: read

concurrency:
  group: customize-${{ github.ref }}
  cancel-in-progress: true

jobs:
  customize:
    runs-on: ubuntu-latest
    env:
      DEVICE: ${{ github.event_name == 'workflow_dispatch' && inputs.device || 'rpi64' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with: { fetch-depth: 1 }

      - name: Ensure scripts dir & perms
        shell: bash
        run: |
          set -eux
          test -d scripts
          chmod -R a+rx scripts

      # ---- Download the base artifact from the other workflow run ----
      # Case 1: triggered by workflow_run (preferred path for chaining)
      - name: Download artifact from triggering base run (no unzip)
        if: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success' }}
        uses: dawidd6/action-download-artifact@v6
        with:
          # keep your existing selector(s) here (run_id / workflow / branch / etc)
          run_id: ${{ github.event.workflow_run.id }}
          # download by REGEX so either "base-input-rpi64" or "base-input-rpi64.img.xz" works
          name: ^base-input-${{ env.DEVICE }}(\.img(\.xz)?|\.zip)?$
          name_is_regexp: true
          search_artifacts: true
          path: build
          skip_unpack: true

      # Case 2: manual dispatch with specific run id
      - name: Download artifact from specific run (manual, no unzip)
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.base_run_id != '' }}
        uses: dawidd6/action-download-artifact@v6
        with:
          # keep your existing selector(s) here (run_id / workflow / branch / etc)
          run_id: ${{ github.event.workflow_run.id }}
          # download by REGEX so either "base-input-rpi64" or "base-input-rpi64.img.xz" works
          name: ^base-input-${{ env.DEVICE }}(\.img(\.xz)?|\.zip)?$
          name_is_regexp: true
          search_artifacts: true
          path: build
          skip_unpack: true

      # Case 3: manual dispatch without run id -> fetch the latest successful artifact
      - name: Download latest successful artifact (manual fallback, no unzip)
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.base_run_id == '' }}
        uses: dawidd6/action-download-artifact@v6
        with:
          # keep your existing selector(s) here (run_id / workflow / branch / etc)
          run_id: ${{ github.event.workflow_run.id }}
          # download by REGEX so either "base-input-rpi64" or "base-input-rpi64.img.xz" works
          name: ^base-input-${{ env.DEVICE }}(\.img(\.xz)?|\.zip)?$
          name_is_regexp: true
          search_artifacts: true
          path: build
          skip_unpack: true

      - name: Extract artifact safely (handles >2GiB)
        shell: bash
        run: |
          set -eux
          ls -l build || true
          ZIP="$(find build -maxdepth 1 -type f -name '*.zip' | head -n1 || true)"
          if [[ -z "${ZIP}" ]]; then
            echo "No ZIP artifact found in build/"; exit 1
          fi

          sudo apt-get update
          # Try unzip; if not present or fails on big files, fall back to 7z
          if sudo apt-get install -y unzip; then
            unzip -o "${ZIP}" -d build || { sudo apt-get install -y p7zip-full; 7z x -y -o"build" "${ZIP}"; }
          else
            sudo apt-get install -y p7zip-full
            7z x -y -o"build" "${ZIP}"
          fi
          ls -l build

      - name: Normalize image path (supports .img and .img.xz)
        shell: bash
        run: |
          set -eux
          # Prefer exact device-named files, then any matching input-*.img(.xz)
          SRC="$(find build -maxdepth 4 -type f -name "input-${DEVICE}.img" -o -name "input-${DEVICE}.img.xz" | head -n1 || true)"
          if [[ -z "${SRC}" ]]; then
            SRC="$(find build -maxdepth 4 -type f \( -name "input-*.img" -o -name "input-*.img.xz" \) | head -n1 || true)"
          fi
          test -n "${SRC}" || (echo "No input image found after extraction"; exit 1)

          # If it's compressed (.xz), decompress to a file we control
          if [[ "${SRC}" == *.xz ]]; then
            sudo apt-get update && sudo apt-get install -y xz-utils
            xz -T0 -dk "${SRC}"            # leaves the .img next to it
            SRC="${SRC%.xz}"
          fi

          mkdir -p build
          mv -f "${SRC}" "build/input-${DEVICE}.img"
          ls -lh build

      - name: Prepare workspace & rename to input.img
        shell: bash
        run: |
          set -eux
          sudo mkdir -p build
          sudo chown -R "$USER":"$USER" build
          chmod -R u+rwX build
          mv -f "build/input-${DEVICE}.img" "build/input.img"
          ls -lh build

      - name: Pull CustoPiZer image
        run: |
          set -eux
          docker pull ghcr.io/octoprint/custopizer:latest

      - name: Sanitize CustoPiZer scripts (no sudo in chroot)
        shell: bash
        run: |
          set -eux
          test -d scripts
          for f in scripts/*.sh; do
            [ -f "$f" ] || continue
            sed -i \
              -e 's/sudo[[:space:]]\+-u[[:space:]]\+pi[[:space:]]\+/runuser -u pi -- /g' \
              -e 's/\bsudo[[:space:]]\+apt-get\b/apt-get/g' \
              -e 's/\bsudo[[:space:]]\+apt\b/apt/g' \
              -e 's/\bsudo[[:space:]]\+systemctl\b/systemctl/g' \
              -e 's/\bsudo[[:space:]]\+chown\b/chown/g' \
              "$f"
            sed -i -e '/apt-get[[:space:]]\+-y[[:space:]]\+install[[:space:]]\+policykit-1/d' "$f" || true
          done
          chmod -R a+rx scripts

      - name: Run CustoPiZer (raw docker, explicit DNS)
        shell: bash
        run: |
          set -eux
          docker run --rm --privileged \
            --dns 8.8.8.8 --dns 1.1.1.1 \
            -v "${GITHUB_WORKSPACE}/build:/CustoPiZer/workspace" \
            -v "${GITHUB_WORKSPACE}/scripts:/CustoPiZer/workspace/scripts" \
            -v "${GITHUB_WORKSPACE}/config.local:/CustoPiZer/config.local" \
            ghcr.io/octoprint/custopizer:latest

          mv -f "${GITHUB_WORKSPACE}/build/output.img" \
                "${GITHUB_WORKSPACE}/build/output-${DEVICE}.img"

      - name: Upload customized image
        uses: actions/upload-artifact@v4
        with:
          name: output-${{ env.DEVICE }}.img
          path: build/output-${{ env.DEVICE }}.img
